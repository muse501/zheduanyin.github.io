<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="zheduanyin's life / mind / tech blog"><meta name="google-site-verification" content="8SYOuO4rdMGx-YyY_c0pnFhtcLEPMeajMW8ZSbLQ6F4"><title>Django 中 ModelForm 的使用 - zheduanyin's life / mind / tech blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><link rel="shortcut icon" type="image/x-icon"><link rel="apple-touch-icon"><link rel="apple-touch-icon-precomposed" href="NaN"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div id="header"><div class="site-name"><h1 class="hidden">Django 中 ModelForm 的使用</h1><a id="logo" href="/.">Loved One</a><p class="subtitle">壁挂相片正在褪色，桌腿给阳光烘得暖洋洋的，地板和墙壁都是用原木码出来的，没有做太多处理，甚至可以透过地面的小树洞看到树下坐着弹 Ukulele 的小男孩儿</p></div><div id="nav-menu"><a href="/."> 首页</a><a href="/archives/"> 归档</a><a href="/about/"> 关于</a><a href="/atom.xml"> 订阅</a></div></div><div id="content"><div class="post container"><h1 class="post-title"><a href="/2016/04/07/Django-中-ModelForm-的使用/">Django 中 ModelForm 的使用</a></h1><div class="post-meta">Apr 7, 2016<span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/04/07/Django-中-ModelForm-的使用/" href="/2016/04/07/Django-中-ModelForm-的使用/#comments" class="ds-thread-count"></a><div class="post-content"><h2 id="什么是-ModelForm"><a href="#什么是-ModelForm" class="headerlink" title="什么是 ModelForm"></a>什么是 ModelForm</h2><p>ModelForm 是 Django 中编写基于 Model 定制表单的方法，可以提高 Model 复用性。</p><p>使用时 Django 会根据 <code>django.db.models.Field</code> (用于数据库衔接) 自动转化为 <code>django.forms.Field</code> (用于表单前端展示、后端验证)。</p><h2 id="定义-ModelForm-表单"><a href="#定义-ModelForm-表单" class="headerlink" title="定义 ModelForm 表单"></a>定义 ModelForm 表单</h2><p>举一个书籍管理例子，这个例子中定义了</p><ul><li>title 字段，存 char，用于储存书籍的标题<ul><li>最大允许长度 20</li><li>数据库唯一值，这意味着数据库不能储存两个相同标题的书</li></ul></li><li>author 字段，存 Author 的外键，指向储存书籍的作者</li></ul><p>Model<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">20</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    author = models.ForeignKey(<span class="string">'Author'</span>)</span><br></pre></td></tr></table></figure></p><p>ModelForm<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Article</span><br></pre></td></tr></table></figure></p><p>用 Form 来构造的话这个 ModelForm 类似这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    title = forms.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    author = forms.ModelChoiceField(queryset=Author.objects.all())</span><br></pre></td></tr></table></figure></p><h3 id="定制-ModelForm-表单"><a href="#定制-ModelForm-表单" class="headerlink" title="定制 ModelForm 表单"></a>定制 ModelForm 表单</h3><p>ModelForm 提供了自定义 Field、错误信息、渲染方法、正反选择模型的字段等。</p><p>如何定制 ModelForm 呢？有两种方式：Meta (ModelForm 独有) 和自定义字段 (普通 Form 中也可使用)。</p><h4 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h4><p>ModelForm 通过 Meta 把 db.Field 自动转化为 forms.Field，其中涉及到几步转化</p><ul><li>validators 不变</li><li>添加 widget 属性，即前端的渲染方式</li><li>修改 Model 包含的字段，通过 fields 来拿指定字段或者通过 exclude 来排除指定字段</li><li>修改错误信息</li></ul><p>我们可以通过下面的例子来看一看如何通过 Meta 来自定义 ModelForm 的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment"># 指定 Model</span></span><br><span class="line">        model = Article</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Form 需要 Model 中的哪几个 Field</span></span><br><span class="line">        fields = [<span class="string">'title'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Form 排除 Model 中的哪几个 Field</span></span><br><span class="line">        exclude = [<span class="string">'author'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自定义 error_message</span></span><br><span class="line">        error_messages = &#123;</span><br><span class="line">            <span class="string">'invalid'</span> = <span class="string">'invalid title'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自定义 widget，这里使用了长 80 列，宽 20 行的 textarea</span></span><br><span class="line">        widgets = &#123;</span><br><span class="line">            <span class="string">'name'</span>: Textarea(attrs=&#123;<span class="string">'cols'</span>: <span class="number">80</span>, <span class="string">'rows'</span>: <span class="number">20</span>&#125;),</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Meta 的缺点是不能修改字段的 validators，如果需要修改 validators，需要在 Meta 外部重新定义一个同名 Field 来覆盖之</p></blockquote><h4 id="在-Form-中另外定义-Field"><a href="#在-Form-中另外定义-Field" class="headerlink" title="在 Form 中另外定义 Field"></a>在 Form 中另外定义 Field</h4><p>这是 Form 中通用的定义 Field 的方法，在 ModelForm 中它有两个作用</p><ol><li>补充 Model 没有的 Field 到表单</li><li>覆盖 Model 中的 Field 定义</li></ol><p>且看下面的例子，Article 中已经包含了 title 字段，我们在 ModelForm 中重新定义了它，把 CharField 改为了 ChoiceField，并且自定义了 validators。</p><p>注意：覆盖 title 的时候，把 title 从 Meta 中 exclude 掉是可选的，去不去掉的区别在于，你是否需要它为你校验 <code>unique=True</code> 这个数据库级限制。在这里我们需要校验，因为 ModelForm 校验通过后我需要把它存入数据库，如果这里没有校验的话，碰到同标题的书数据库就会在储存时报错，我们希望把这步校验放在 ModelForm 的校验中，而不是在通过校验后再用 <code>try... catch...</code> 来捕获它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    title = forms.ChoiceFied(choices=((<span class="number">1</span>, <span class="string">'罗宾汉'</span>), (<span class="number">2</span>, <span class="string">'田伯光'</span>),), validators=MaxValueValidator(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Article</span><br></pre></td></tr></table></figure><h3 id="值得一提的一些-Field-转化"><a href="#值得一提的一些-Field-转化" class="headerlink" title="值得一提的一些 Field 转化"></a>值得一提的一些 Field 转化</h3><h4 id="AutoField"><a href="#AutoField" class="headerlink" title="AutoField"></a>AutoField</h4><p>该 Field 不会出现在 ModelForm 表单中。</p><blockquote><p>所有 <code>editable=False</code> 的 Field 都不会出现在 ModelForm 中。</p></blockquote><h4 id="BooleanField"><a href="#BooleanField" class="headerlink" title="BooleanField"></a>BooleanField</h4><p>由于表单提交时统一识别为 string，而 <code>BooleanField</code> 是用 python 中的 <code>bool</code> 来判断的，所以只要传了任意非空值，<code>BooleanField</code> 都会当做 True 来处理，而如果传了空值，由于 <code>forms.Field</code> 默认属性是 <code>required=True</code>，会校验失败，所以如果你需要一个可以填 False 的 Field，那么你需要在 Form 中手动设置这个 Field 的 <code>required=False</code>。</p><h4 id="ForeignKey"><a href="#ForeignKey" class="headerlink" title="ForeignKey"></a>ForeignKey</h4><p>ForeignKey 自动转化为 ModelChoiceField，用下拉选项菜单渲染，默认渲染出来的选项显示为对应 Field 的 <code>__str__</code>，提交的值为对应 Field 的 <code>id</code>，这些都可以定制。</p><p>在后端接收提交的时候会自动在对应的 Model 中用 id 去找，如果没找到则抛出 ValidationError。</p><h4 id="ManyToManyField"><a href="#ManyToManyField" class="headerlink" title="ManyToManyField"></a>ManyToManyField</h4><p>ManyToManyField 自动转化为 ModelMultipleChoiceField，用多选框渲染，同样默认渲染出来的选项显示为对应 Field 的 <code>__str__</code>，提交的值为对应 Field 的 <code>id</code> 值。</p><p>比如有个叫 group 的 ManyToManyField，选中了 <code>&#39;finance&#39;</code> <code>&#39;develop&#39;</code> 这两个选项，他们的 id 分别为 1 和 2，那么世界上提交的表单 QueryString 就是 <code>group=1&amp;group=2</code></p><h2 id="初始化-ModelForm-表单"><a href="#初始化-ModelForm-表单" class="headerlink" title="初始化 ModelForm 表单"></a>初始化 ModelForm 表单</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">form = ArticleForm(request.POST)</span><br></pre></td></tr></table></figure><ul><li>校验的时候可以定义 instance 参数来给 ModelForm 初始化实例，即后续的修改都作用在这个实例上</li><li><p>可以定义 initial 参数来给 ModelForm 初始值，同名 Field 会覆盖 instance 的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">article = Article.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">author = Author.objects.first()</span><br><span class="line"></span><br><span class="line">form = ArticleForm(request.POST, instance=article, initial=&#123;<span class="string">'author'</span>: author&#125;)</span><br><span class="line"><span class="comment"># 到这里的时候 form 已经绑定到 article 对象了，并且 author Field 的初始值为 author 对象。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> form.is_valid():</span><br><span class="line">    form.save()</span><br></pre></td></tr></table></figure><blockquote><p>这里数据加载的先后顺序为 instance &lt; initial &lt; request.POST</p></blockquote></li></ul><h2 id="校验-ModelForm-表单"><a href="#校验-ModelForm-表单" class="headerlink" title="校验 ModelForm 表单"></a>校验 ModelForm 表单</h2><blockquote><p>注意：Form 只会检查内部定义过的 Field，request.POST 中其余 keyword 都会被无视和过滤掉，即不会出现在返回的 cleaned_data 中。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">form = ArticleForm(request.POST)</span><br><span class="line"><span class="comment"># 校验表单</span></span><br><span class="line"><span class="keyword">if</span> form.is_valid():</span><br><span class="line">    <span class="comment"># 保存到数据库</span></span><br><span class="line">    article = form.save()</span><br></pre></td></tr></table></figure><p><code>is_valid()</code> 会调用 <code>full_clean()</code>来对表单进行全面校验，它又分成三步（定义在基类 Form）中</p><ol><li>根据每个 Field 来做单个 Field 的校验 ( 比如 title 字段就会校验是否超出最大允许长度 20 ) 其中在 <code>Field.clean()</code> 执行过后提供了钩子 <code>clean_[field_name]</code></li><li>根据 Form 定义的 Field 之间的依赖关系做整个表单的校验，钩子方法为 <code>clean()</code></li><li>自定义校验通过后的表单处理，钩子叫 <code>_post_clean()</code><ul><li>这一步中，ModelForm 做了一些额外的检验：如果定义在 Meta 中的 Field 有 <code>unique=True</code> 这个限制，那么 ModelForm 则会按照现有数据库中的数据对其校验，看这个 Field 的值是否已存在，如果已存在，则抛出一个 <code>IntegrityError</code>。实际操作中如果强制不校验 unique 的话，可以把该字段从 Meta 中移除，在 ModelForm 中重新定义该字段。</li></ul></li></ol><h2 id="储存-ModelForm-对象"><a href="#储存-ModelForm-对象" class="headerlink" title="储存 ModelForm 对象"></a>储存 ModelForm 对象</h2><p>调用 <code>save()</code> 的时候可以添加 <code>commit=False</code> 来避免立即储存，从而通过后续的修改或补充来得到完整的 Model 实例后再储存到数据库。</p><p>如果初始化的时候传入了 instance，那么调用 <code>save()</code> 的时候会用 ModelForm 中定义过的字段值覆盖传入实例的相应字段，并写入数据库。</p><p><code>save()</code> 同样会帮你储存 ManyToManyField，如果 save 时使用了 <code>commit=False</code>，那么 ManyToManyField 的储存需要等该条目存入数据库之后手动调用 ModelForm 的 <code>save_m2m()</code> 方法。</p><h3 id="使用同一表单来-新建-更新-指定实例"><a href="#使用同一表单来-新建-更新-指定实例" class="headerlink" title="使用同一表单来 新建 | 更新 指定实例"></a>使用同一表单来 新建 | 更新 指定实例</h3><p>通常的步骤分为如下几步</p><ul><li>检测该对象是否已在数据库<ul><li>如果已存在，那么需要手动获取该实例，然后更改相关 field 内容，最后使用 <code>update()</code> 方法保存到数据库</li><li>如果不存在，新建一个 Model 实例并修改至完整的 Model，调用 <code>save()</code> 方法保存到数据库</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f = AuthorForm(request.POST)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> f.is_valid():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Save the new instance.</span></span><br><span class="line">        new_author = f.save(commit=<span class="keyword">False</span>)</span><br><span class="line">        new_author.some_field = f.cleaned_data[<span class="string">'some_field'</span>]</span><br><span class="line">        new_author.save()</span><br><span class="line">    <span class="keyword">except</span> IntegrityError:</span><br><span class="line">        <span class="comment"># 已存在</span></span><br><span class="line">        <span class="comment"># 若要这样使用 update 的话需要在 cleaned_data 中加入上述 some_field 的改动</span></span><br><span class="line">        <span class="comment"># 因为 some_field 的改动只在 new_author 中使用，并不能更新到数据库</span></span><br><span class="line">        Author.objects.filter(pk=f.cleaned_data[<span class="string">'pk'</span>]).update(f.cleaned_data)</span><br></pre></td></tr></table></figure><p>太麻烦了！其实 Django 中已经有 <code>update_or_create</code> 方法已经实现了上述所有功能，可以避免这个 <code>try ... except ...</code> 判断实例是否已存在，我们来看这个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># forms.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorAddForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    <span class="comment"># 确保 pk 不是必须字段</span></span><br><span class="line">    <span class="comment"># 如果不传，自动识别为 None</span></span><br><span class="line">    pk = forms.IntegerField(required=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Author</span><br><span class="line">        fields = [<span class="string">'name'</span>, <span class="string">'address'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_post_clean</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(forms.ModelForm, self)._post_clean()</span><br><span class="line">        <span class="comment"># 不传 pk 的话表示需要新建一个条目</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.cleaned_data[<span class="string">'pk'</span>]:</span><br><span class="line">            <span class="comment"># 添加需要的 Field</span></span><br><span class="line">            self.cleaned_data[<span class="string">'Origin'</span>] = City.objects.get(Province=<span class="string">'北京'</span>, City=<span class="string">'北京'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorsView</span><span class="params">(LoginRequiredMixin, TemplateView)</span>:</span></span><br><span class="line">    template_name = <span class="string">'authors.html'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        form = AuthorAddForm(request.POST)</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> form.is_valid():</span><br><span class="line">            <span class="keyword">return</span> form.errors</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果 pk 不存在，为 None，那么 update_or_create 匹配失败，从而进入 create 流程</span></span><br><span class="line">        <span class="comment"># 否则 pk 存在表单中，那么尝试匹配数据库，如果命中，进行 update 操作，否则进行 create 操作</span></span><br><span class="line">        Author, created = Author.objects.update_or_create(pk=form.cleaned_data[<span class="string">'pk'</span>], defaults=form.cleaned_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Author.pk</span><br></pre></td></tr></table></figure><p>其中 <code>update_or_create</code> 通过检测所有非 defaults 的字段，在上述例子中就是 <code>id=form.cleaned_data[&#39;id&#39;]</code> 一项是否已存在于数据库而判断是用 <code>update()</code> 还是 <code>create()</code>，而不论是 <code>update()</code> 还是 <code>create()</code>，都会使用 cleaned_data 作为数据源来写入数据库。</p></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.iloved.one/2016/04/07/Django-中-ModelForm-的使用/" data-id="circ5r5cs0008h98nsg1jlf8n" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Django/">Django</a><a href="/tags/Tech/">Tech</a></div><div class="post-nav"><a href="/2016/04/09/Django-弱密码校验那些事/" class="pre">Django 弱密码校验那些事</a><a href="/2016/03/20/Ukulele-See-You-Again/" class="next">See You Again | Ukulele TAB谱</a></div><div data-thread-key="2016/04/07/Django-中-ModelForm-的使用/" data-title="Django 中 ModelForm 的使用" data-url="http://blog.iloved.one/2016/04/07/Django-中-ModelForm-的使用/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/04/07/Django-中-ModelForm-的使用/" data-title="Django 中 ModelForm 的使用" data-url="http://blog.iloved.one/2016/04/07/Django-中-ModelForm-的使用/" data-author-key="1" class="ds-thread"></div></div></div><div id="footer"><div id="footer">© <a href="/." rel="nofollow">Loved One</a><span id="busuanzi_container_site_uv"> 🎼  访客数 </span><span id="busuanzi_value_site_uv"></span><span> 🎵 </span><br><spen>在这个奇葩的时代，只愿做一个不奇葩的男人</spen></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'ilovedone'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-75688320-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a3ac28266bf59d2c9c476373df7553f8";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="/js/toc.js?v=0.0.0" async></script><script type="text/javascript" src="/js/scroll_to_animation.js?v=0.0.0" async></script></body></html>